
import installSynApps
import shutil
import os
from sys import platform
from installSynApps.io import logger as LOG
import datetime
import re

# External areaDetector plugins
ad_plugins = ['ADCompVision', 'ADPluginBar', 'ADPluginEdge', 'ADPluginDmtx']

# Bash shebang length limit is 127 characters, so we need to make sure we account for that
KERNEL_PATH_LIMIT = 127


class DummyIOCGenerator:

    def __init__(self, install_config):
        self.install_config         = install_config
        self.ioc_template_dir       = None


    def get_env_paths_name(self, module):

        if module == 'seq':
            return 'SNCSEQ'
        elif module == 'iocStats':
            return 'DEVIOCSTATS'
        elif module == 'areaDetector':
            return 'AREA_DETECTOR'
        elif module == 'allenBradley':
            return 'ALLEN_BRADLEY'
        else:
            return module.upper()


    def generate_env_paths(self, ioc_top_path, ioc_boot_path, target, action):

        LOG.debug('Generating template envPaths based on compiled binaries...')
        ioc_path = installSynApps.join_path(self.ioc_template_dir, action.ioc_name)
        envPaths_fp = open(installSynApps.join_path(ioc_path, 'envPaths'), 'w')

        arch='linux-x86_64'
        if platform == 'win32':
            arch = 'windows-x64-static'

        envPaths_fp.write('# Relative envPaths file auto-generated by installSynApps\n#\n')
        envPaths_fp.write('# The BUNDLE_LOC env variable is set in st.cmd. Please edit to top bundle location\n#\n')
        envPaths_fp.write('epicsEnvSet("ARCH", "{}")\n'.format(arch))
        envPaths_fp.write('epicsEnvSet("TOP", "{}")\n'.format(ioc_top_path))

        base_path = installSynApps.join_path('$(BUNDLE_LOC)', 'base')
        envPaths_fp.write('epicsEnvSet("EPICS_BASE",{}"{}")\n'.format((' ' * 14), base_path))

        support_path = "$(BUNDLE_LOC)"
        support_path = installSynApps.join_path(support_path, "support")
        envPaths_fp.write('epicsEnvSet("SUPPORT",{}"{}")\n\n'.format((' ' * 17), support_path))

        for dir in os.listdir(self.install_config.support_path):
            mod_path = installSynApps.join_path(self.install_config.support_path, dir)
            if os.path.isdir(mod_path) and dir not in ['base', 'configure', 'utils', 'documentation', '.git', 'lib', 'bin']:
                mod_path = installSynApps.join_path('$(SUPPORT)', dir)
                envPaths_fp.write('epicsEnvSet("{}",{}"{}")\n'.format(self.get_env_paths_name(dir), ' ' * (24 - len(self.get_env_paths_name(dir))), mod_path))

        envPaths_fp.write('\n')

        for dir in os.listdir(self.install_config.ad_path):
            mod_path = installSynApps.join_path(self.install_config.ad_path, dir)
            if os.path.isdir(mod_path) and dir not in ['configure', 'docs', 'documentation', 'ci', '.git', '']:
                mod_path = installSynApps.join_path('$(AREA_DETECTOR)', dir)
                envPaths_fp.write('epicsEnvSet("{}",{}"{}")\n'.format(self.get_env_paths_name(dir), ' ' * (24 - len(self.get_env_paths_name(dir))), mod_path))

        envPaths_fp.close()


    def create_config_file(self, action):

        LOG.debug('Generating config file for use with procServ...')
        ioc_path = installSynApps.join_path(self.ioc_template_dir, action.ioc_name)
        config_fp = open(installSynApps.join_path(ioc_path, 'config'), 'w')
        config_fp.write('NAME={}\nPORT={}\nUSER=softioc\nHOST={}\n'.format(action.ioc_name, '4000', 'localhost'))
        config_fp.close()


    def find_paths_for_action(self, driver_type):
        """Finds ioc_top, executable, and iocBoot folder for IOCAction
        """

        try:

            driver_path = installSynApps.join_path(self.install_config.ad_path, driver_type)


            ioc_top_path = '$(BUNDLE_LOC)/support/areaDetector/{}'.format(driver_type)

            # identify the IOCs folder
            for name in os.listdir(driver_path):
                if "ioc" == name or "iocs" == name:
                    driver_path = installSynApps.join_path(driver_path, name)
                    ioc_top_path = installSynApps.join_path(ioc_top_path, name)
                    break

            # identify the IOC 
            for name in os.listdir(driver_path):
                # Add check to see if NOIOC in name - occasional problems generating ADSimDetector
                if ("IOC" in name or "ioc" in name) and "NOIOC" not in name.upper():
                    driver_path = installSynApps.join_path(driver_path, name)
                    ioc_top_path = installSynApps.join_path(ioc_top_path, name)
                    break


            # find the driver executable
            executable_path = installSynApps.join_path(driver_path, "bin")
            # There should only be one architecture in the bundle
            for name in os.listdir(executable_path):
                executable_path = installSynApps.join_path(executable_path, name)
                break

            # We look for the executable that ends with App
            for name in os.listdir(executable_path):
                if 'App' in name:
                    executable_path = installSynApps.join_path(executable_path, name)
                    break

            iocBoot_path = installSynApps.join_path(driver_path, 'iocBoot')
            for dir in os.listdir(iocBoot_path):
                if dir.startswith('ioc') and os.path.isdir(installSynApps.join_path(iocBoot_path, dir)):
                    iocBoot_path = installSynApps.join_path(iocBoot_path, dir)
                    break
            return ioc_top_path, executable_path, iocBoot_path
        except:
            return None, None, None


    def get_lib_path_for_module(self, module_path, architecture, delimeter):
        """Generates a library path for specific module
        """

        bin_loc = installSynApps.join_path(module_path, 'bin')
        bin_loc = installSynApps.join_path(bin_loc, architecture)
        lib_loc = installSynApps.join_path(module_path, 'lib')
        lib_loc = installSynApps.join_path(lib_loc, architecture)
        return bin_loc + delimeter + lib_loc + delimeter


    def get_lib_path_str(self, action):
        """Function that generates library path for shared built iocs

        Parameters
        ----------
        action : IOCAction
            ioc action for which we are generating lib path.

        Returns
        -------
        lib_path : str
            Library path set in form of str
        """

        lib_path_str = ''
        if platform == "win32":
            delimeter = ';'
            closer = '%PATH%"'
            arch='windows-x64-static'
            
        else:
            arch = 'linux-x86_64'
            delimeter = ':'
            closer = '$LD_LIBRARY_PATH'


        if platform == "win32":
            lib_path_str += 'SET BUNLDE_LOC={}\n\nSET "PATH='.format(self.install_config.install_location)
        else:
            lib_path_str += 'export BUNDLE_LOC={}\n\nexport LD_LIBRARY_PATH='.format(self.install_config.install_location)

        lib_path_str += self.get_lib_path_for_module(installSynApps.join_path('$BUNDLE_LOC', 'base'), arch, delimeter)

        support_dir = installSynApps.join_path('$BUNDLE_LOC', 'support')
        ad_dir = installSynApps.join_path(support_dir, 'areaDetector')

        if os.path.exists(self.install_config.support_path) and os.path.isdir(self.install_config.support_path):
            for dir in os.listdir(self.install_config.support_path):
                mod_path_abs = installSynApps.join_path(self.install_config.support_path, dir)
                mod_path_rel = installSynApps.join_path(support_dir, dir)
                if os.path.isdir(mod_path_abs) and dir != "base" and dir != "areaDetector":
                    lib_path_str += self.get_lib_path_for_module(mod_path_rel, arch, delimeter)

        if os.path.exists(self.install_config.ad_path) and os.path.isdir(self.install_config.ad_path):
            for dir in os.listdir(self.install_config.ad_path):
                mod_path_abs = installSynApps.join_path(self.install_config.ad_path, dir)
                mod_path_rel = installSynApps.join_path(ad_dir, dir)
                if os.path.isdir(mod_path_abs) and (dir == 'ADCore' or dir == 'ADSupport' or dir in ad_plugins or dir == action.ioc_type):
                    lib_path_str += self.get_lib_path_for_module(mod_path_rel, arch, delimeter)

        lib_path_str += closer
        return lib_path_str


    def initialize_st_base_file(self, ioc_path, lib_path, executable_path):
        """Function responsible for handling executable path injection, and base file creation
        """

        # Setup st.cmd to be executable, rest will be in st_base.cmd
        LOG.debug('Setting up executable st.cmd with library path')
        st_exe = open(installSynApps.join_path(ioc_path, 'st.cmd'), 'w+')

        executable_path_rel = '$BUNDLE_LOC/support/{}'.format(executable_path.split('support/')[1])
            
        if platform == 'win32':
            st_exe.write('@echo OFF\n\n{}\n\n{} st_base.cmd\n'.format(lib_path, executable_path_rel))
        else:
            st_exe.write('#!/bin/bash\n\n{}\n\n{} st_base.cmd\n'.format(lib_path, executable_path_rel))


        
        st_exe.close()
        st = open(installSynApps.join_path(ioc_path, "st_base.cmd"), "w+")

        return st


    def generate_st_cmd(self, action, executable_path, st_base_path):

        LOG.debug('Generating st.cmd using base file:\n{}'.format(st_base_path))
        ioc_path        = installSynApps.join_path(self.ioc_template_dir, action.ioc_name)

        
       
        lib_path  = self.get_lib_path_str(action)
        
        # Create base st.cmd, add call to executable
        st = self.initialize_st_base_file(ioc_path, lib_path, executable_path)

        LOG.debug('Writing base st.cmd file')

        # Define envPaths
        st.write('< envPaths\n\n')

        # Open existing st.cmd base file
        st_base_fp = open(st_base_path, 'r')

        # Read through the lines, add a 'unique.cmd' call after all env sets, and add envSet calls to action environment
        lines = st_base_fp.readlines()
        wrote_unique = False
        for line in lines:
            if line.startswith('#!') or 'unique.cmd' in line or 'envPaths' in line:
                pass
            elif line.startswith('#'):
                st.write(line)
            elif 'Config(' in line and not wrote_unique:
                st.write('\n< unique.cmd\n\n')
                st.write(line)
                wrote_unique = True
            elif line.startswith('epicsEnvSet'):
                action.add_to_environment(line)
                st.write(line)
            else:
                st.write(line)

        st_base_fp.close()
        st.close()

        # Collect environment variables set in any other files
        self.grab_additional_env(action, st_base_path)
        # Make st.cmd executable.
        os.chmod(installSynApps.join_path(ioc_path, "st.cmd"), 0o755)


    def generate_unique_cmd(self, action):

        LOG.debug('Generating template unique.cmd from ioc environment...')
        ioc_path = installSynApps.join_path(self.ioc_template_dir, action.ioc_name)
        unique_fp = open(installSynApps.join_path(ioc_path, 'unique.cmd'), 'w')

        unique_fp.write('###############################################################\n')
        unique_fp.write('# installSynApps Auto-Generated IOC Template{:<19}#\n'.format(''))
        unique_fp.write('# Meant for use with bundles running ADCore {:<19} #\n'.format(self.install_config.get_core_version()))
        unique_fp.write('# Generated: {:<53}#\n'.format(str(datetime.datetime.now())))
        unique_fp.write('###############################################################\n\n\n')

        for env_var in action.epics_environment.keys():
            unique_fp.write('epicsEnvSet("{}",{}"{}")\n'.format(env_var, ' ' * (32 - len(env_var)), action.epics_environment[env_var]))

        unique_fp.close()


    def grab_additional_env(self, action, st_base_path):
        """Function that collects any additional environment variables for IOC
        """

        iocBoot_dir = os.path.dirname(st_base_path)
        st_file = os.path.basename(st_base_path)

        for file in os.listdir(iocBoot_dir):
            # For any file that isnt the base file, add environment variables.
            if file.startswith('st') and file.endswith('.cmd') and file != st_file:
                fp = open(installSynApps.join_path(iocBoot_dir, file), 'r')
                lines = fp.readlines()
                for line in lines:
                    if line.startswith('epicsEnvSet'):
                        action.add_to_environment(line)
                fp.close()


    def grab_dependencies_from_bundle(self, ioc_path, iocBoot_path):

        LOG.debug('Collecting additional iocBoot files from bundle...')
        for file in os.listdir(iocBoot_path):
            target = installSynApps.join_path(iocBoot_path, file)
            if os.path.isfile(target):
                if not file.startswith(('Makefile', 'st', 'test', 'READ', 'dll', 'envPaths')) and not file.endswith(('.xml', '.txt')):
                    shutil.copyfile(target, installSynApps.join_path(ioc_path, file))


    def create_dummy_ioc(self, action):

        LOG.debug("-------------------------------------------")
        LOG.debug("Setup process for dummy IOC template " + action.ioc_name)
        LOG.debug("-------------------------------------------")

        ioc_top_path, executable_path, iocBoot_path = self.find_paths_for_action(action.ioc_type)
        
        if executable_path is None:
            LOG.debug('Warning - Could not find binary for {}, skipping...'.format(action.ioc_type))
            return
        elif ioc_top_path is None or iocBoot_path is None:
            LOG.debug('WARNING - Could not find ioc top and iocBoot folder, for {}. Skipping...'.format(action.ioc_type))
        
        if os.path.exists(installSynApps.join_path(self.ioc_template_dir, action.ioc_name)):
            shutil.rmtree(installSynApps.join_path(self.ioc_template_dir, action.ioc_name))
        
        LOG.debug('Generating template IOC for {}...'.format(action.ioc_type))

        ioc_path = installSynApps.join_path(self.ioc_template_dir, action.ioc_name)
        os.mkdir(ioc_path)
        os.mkdir(installSynApps.join_path(ioc_path, 'autosave'))

        current_base_len = 0
        current_base = None
        for file in os.listdir(iocBoot_path):
            next = installSynApps.join_path(iocBoot_path, file)
            if os.path.isfile(next) and file.startswith('st'):
                fp = open(next, 'r')
                lines = fp.readlines()
                fp.close()
                if len(lines) > current_base_len:
                    current_base = next
                    current_base_len = len(lines)

        if current_base is None:
            LOG.debug('ERROR - Could not fine suitable st_base file. Aborting...')
            return

        self.generate_st_cmd(action, executable_path, current_base)
        self.generate_unique_cmd(action)
        self.generate_env_paths(ioc_top_path, iocBoot_path, ioc_path, action)
        self.grab_dependencies_from_bundle(ioc_path, iocBoot_path)

        self.create_config_file(action)
        #self.make_ignore_files(action) TODO
        LOG.debug('Done.')


    def init_template_dir(self, bundle_dir):
        self.ioc_template_dir = installSynApps.join_path('__temp__', bundle_dir, 'ioc-templates')
        if not os.path.exists(self.ioc_template_dir):
            os.mkdir(self.ioc_template_dir)


    def generate_dummy_iocs(self):

        LOG.write('Generating dummy IOCs for included driver binaries')
        dummy_ioc_actions = []
        for module in self.install_config.get_module_list():
            if module.name.startswith('AD') and os.path.exists(installSynApps.join_path(module.abs_path, 'iocs')):
                dummy_ioc_actions.append(DummyIOCAction(os.path.basename(module.abs_path)))
        
        for action in dummy_ioc_actions:
            self.create_dummy_ioc(action)

        LOG.write('Done.')



class DummyIOCAction:
    """Helper class that stores information and functions for each IOC in the CONFIGURE file
    
    Attributes
    ----------
    ioc_type : str
        name of areaDetector driver instance the IOC is linked to ex. ADProsilica
    ioc_name : str
        name of the IOC ex. cam-ps1
    ioc_prefix : str
        Prefix used by the IOC
    asyn_port : str
        asyn port used for outputting NDArrays
    ioc_port : str
        telnet port on which procserver will run the IOC
    connection : str
        Value used to connect to the device ex. IP, serial num. etc.
    """


    def __init__(self, driver_type):
        """Constructor for the IOCAction class
        """

        self.epics_environment              = {}
        self.ioc_name                       = '{}-template'.format(driver_type.lower()[2:])
        self.ioc_type                       = driver_type
        self.epics_environment['IOCNAME']   = self.ioc_name
        self.epics_environment['ENGINEER']  = 'Dummy Engineer'


    def add_to_environment(self, line):
        try:
            line_s = line.strip()
            line_s = re.sub('"', '', line_s)
            line_s = re.sub('\t', '', line_s)
            line_s = re.sub(' +', '', line_s)
            line_s = re.sub('epicsEnvSet', '', line_s)
            temp = line_s.split(',')
            self.epics_environment[temp[0][1:]] = temp[1][:-1]
        except IndexError:
            LOG.debug('Error, failed to parse epics environment variable.')
