"""Module responsible for generating README files and bash build scripts once the package/sources are built
"""


# Python library imports
import os
import sys
from sys import platform
import shutil
import datetime
import subprocess

# InstallSynApps internal imports
import installSynApps
import installSynApps.DataModel.install_config as IC
from installSynApps.IO import config_writer as WRITER
from installSynApps.IO import logger as LOG

# External package used to identify linux distribution version. Note that this adds external
# dependancy, but it is required because the platform.linuxdistro() function is being deprecated
WITH_DISTRO=True
try:
    import distro
except ImportError:
    # user does not have distro installed, so generic name will be used.
    WITH_DISTRO=False


class FileGenerator:
    """Class responsible for auto-generating install, uninstall, and README files for a given install config

    Attributes
    ----------
    install_config : InstallConfiguration
        currently loaded install configuration
    message : str
        Simple autogenerated message at the top of scripts
    OS : str
        used for naming on linux. Allows for using different bundles for different linux distributions

    Methods
    -------
    initialize_dir()
        Creates autogenerated directory
    generate_install()
        generates install bash script
    generate_uninstall()
        generates an uninstall bash script
    generate_readme_simple()
        generates simplified readme file
    find_isa_version()
        Function that attempts to get the version of installSynApps used.
    write_readme_heading()
        Simple helper function used to write headings for README file sections
    generate_module_version_info()
        Function that gets string with module version information
    write_included_modules_to_readme()
        Function that writes module + version info to readme file
    grab_configuration_used()
        Function that includes the install configuration into the bundle for reuse.
    generate_build_config()
        Function that writes the build configuration used to create the source/binary package.
    generate_readme()
        generates readme based on install config
    autogenerate_all()
        calls all other generation methods
    """


    def __init__(self, install_config):
        """Constructor for FileGenerator
        """

        self.install_config = install_config
        self.message = "# This script was autogenerated by installSynApps on {}\n# The module is available at https://github.com/epicsNSLS2-deploy/installSynApps\n\n".format(datetime.datetime.now())

        global WITH_DISTRO
        if platform == 'win32':
            self.OS = 'Windows'
        elif WITH_DISTRO:
            v = distro.linux_distribution(full_distribution_name=False)
            self.OS = '{}_{}'.format(v[0], v[1])
        else:
            self.OS = 'Linux'



    def initialize_dir(self):
        """Function that creates an autogenerated directory
        """

        autogenerated_dir = os.path.join(self.install_config.install_location, "autogenerated")
        if os.path.exists(autogenerated_dir):
            shutil.rmtree(autogenerated_dir)
        
        os.mkdir(autogenerated_dir)


    def generate_install(self):
        """Function that generates an install file based on currently loaded install_config
        """

        install_fp = open(self.install_config.install_location + "/autogenerated/install.sh", "w+")
        install_fp.write("#!/bin/bash\n")
        
        install_fp.write(self.message)

        for module in self.install_config.get_module_list():
            if module.build == "YES":
                install_fp.write("{}={}\n".format(module.name, module.abs_path))

        for module in self.install_config.get_module_list():
            if module.build == "YES":
                install_fp.write("cd ${}\n".format(module.name))
                install_fp.write("make -sj\n")

        install_fp.close()


    def generate_uninstall(self):
        """Function that generates an uninstall file based on currently loaded install_config
        """

        uninstall_fp = open(self.install_config.install_location + "/autogenerated/uninstall.sh", "w+")
        uninstall_fp.write("#!/bin/bash\n")

        uninstall_fp.write(self.message)

        modules = self.install_config.get_module_list()
        modules.reverse()

        for module in modules:
            if module.build == "YES":
                uninstall_fp.write("{}={}\n".format(module.name, module.abs_path))

        for module in modules:
            if module.build == "YES":
                uninstall_fp.write("cd ${}\n".format(module.name))
                uninstall_fp.write("make clean uninstall\n")
                uninstall_fp.write("make clean uninstall\n")
    
        modules.reverse()
        uninstall_fp.close()


    def generate_readme_simple(self):
        """Generates README file based on configuration

        Function that takes the currently loaded install configuration, 
        and writes a readme file describing modules and versions
        """

        if os.path.exists(self.install_config.install_location + "/INSTALL_README.txt"):
            os.remove(self.install_config.install_location + "/INSTALL_README.txt")
        readme_fp = open(self.install_config.install_location + "/INSTALL_README.txt", "w+")
        readme_fp.write("Autogenerated installSynApps README file created on {}\n".format(datetime.datetime.now()))
        readme_fp.write("https://github.com/epicsNSLS2-deploy/installSynApps\n")
        readme_fp.write("-------------------------------------------------------\n")
        readme_fp.write("The following modules were installed with the following version numbers:\n\n")
        for module in self.install_config.get_module_list():
            if module.build == "YES":
                readme_fp.write("{} -> {}\n".format(module.name, module.version))
        
        readme_fp.write("-------------------------------------------------------\n")
        readme_fp.write("The following modules were cloned with the given versions but not auto-built\n\n")
        
        for module in self.install_config.get_module_list():
            if module.build == "NO" and module.clone == "YES":
                readme_fp.write("{} -> {}\n".format(module.name, module.version))
        
        readme_fp.close()


    def find_isa_version(self):
        """Function that attempts to get the version of installSynApps used.

        Returns
        -------
        str
            The version string for installSynApps. Either hardcoded version, or git tag description
        str
            None if git status not available, otherwise hash of current installSynApps commit.
        """

        isa_version = installSynApps.__version__
        commit_hash = None

        try:
            LOG.debug('git describe --tags')
            out = subprocess.check_output(['git', 'describe', '--tags'])
            isa_version = out.decode('utf-8').strip()
            LOG.debug('git rev-parse HEAD')
            out = subprocess.check_output(['git', 'rev-parse', 'HEAD'])
            commit_hash = out.decode('utf-8')
        except:
            LOG.debug('Could not find git information for installSynApps versions, defaulting to internal version.')

        return isa_version, commit_hash


    def write_readme_heading(self, text, readme_fp):
        """Simple helper function used to write headings for README file sections
        """

        readme_fp.write('{}\n#{}#\n# {:<61}#\n#{}#\n{}\n\n'.format('#' * 64, ' '* 62, text, ' '* 62, '#' * 64))


    def generate_module_version_info(self, module):
        """Function that gets string with module version information

        Parameters
        ----------
        module : installSynApps.DataModel.install_module.InstallModule
            The module we want to generate the information for
        
        Returns
        -------
        info : str
            String with module name and version information on single line
        """
        
        try:
            if module.url_type == 'GIT_URL':
                current_loc = os.getcwd()
                LOG.debug('cd {}'.format(module.abs_path))
                os.chdir(module.abs_path)
                LOG.debug('git describe --tags')
                out = subprocess.check_output(['git', 'describe', '--tags'])
                LOG.debug('Checking version for {}'.format(module.name))
                LOG.debug('cd {}'.format(current_loc))
                os.chdir(current_loc)
                LOG.debug('Detected git tag/version: {} for module {}'.format(out.decode("utf-8").strip(), module.name))
                return '{:<16}- {}'.format(module.name, out.decode("utf-8"))
            else:
                LOG.debug('Detected version {} for module {}'.format(module.version, module.name))
                return '{:<16}- {}\n'.format(module.name, module.version)
        except subprocess.CalledProcessError:
            return ''


    def write_included_modules_to_readme(self, installation_type, add_on_module, readme_fp):
        """Function that writes module + version info to readme file

        Parameters
        ----------
        installation_type : str
            The type of package generated
        add_on_module : installSynApps.DataModel.install_module.InstallModule
            If not None, module being packaged as add on
        readme_fp : file pointer
            Open file pointer for README file.
        """

        for module in self.install_config.get_module_list():
            if not os.path.exists(module.abs_path):
                # If path doesn't exist, do nothing
                pass
            elif installation_type == 'source' and module.build == 'YES':
                # if source, we only care if module was built
                readme_fp.write(self.generate_module_version_info(module))
            elif installation_type == 'bundle' and module.package == 'YES':
                # If bundle, we only include packaged modules
                readme_fp.write(self.generate_module_version_info(module))
            elif installation_type == 'addon' and module.name == add_on_module.name:
                # if add-on, only include add-on module
                readme_fp.write(self.generate_module_version_info(module))


    def grab_configuration_used(self, top_location, module, readme_fp):
        """Function that includes the install configuration into the bundle for reuse.
        
        Parameters
        ----------
        top : str
            resulting location - __temp__
        """

        try:
            isa_version, isa_commit_hash = self.find_isa_version()
            self.generate_build_config(top_location, module, readme_fp)
            readme_fp.write('Build configuration:\n\n')
            readme_fp.write('installSynApps Version: {}\n\n'.format(isa_version))
            readme_fp.write('To grab this version:\n\n    git clone https://github.com/epicsNSLS2-deploy/installSynApps\n')
            if isa_commit_hash is not None:
                readme_fp.write('    git checkout {}\n'.format(isa_commit_hash))
            else:
                readme_fp.write('    git checkout -q {}\n'.format(isa_version))
            readme_fp.write('To regenerate sources for this bundle, grab installSynApps, and run:\n\n')
            readme_fp.write('    ./installCLI.py -c $BUILD_CONFIG -i $INSTALL_LOCATION -p\n\n')
            readme_fp.write('where $BUILD_CONFIG is the path to the build-config directory,\n')
            readme_fp.write('and $INSTALL_LOCATION is your target install path.\n\n{}\n'.format('-' * 64))
            readme_fp.write('{:<20}{}\n'.format('Python 3 Version:', sys.version.split()[0]))
            readme_fp.write('{:<20}{}\n'.format('OS Class:', self.OS))
            readme_fp.write('{:<20}{}\n'.format('Build Date:', datetime.datetime.now()))
        except:
            LOG.debug('Failed to copy install configuration into bundle.')


    def generate_readme(self, installation_name, installation_type='source', readme_path=None, module=None):
        """Function used to generate a README file that includes version/build information

        Parameters
        ----------
        installation_name : str
            Name of the output source/binary bundle
        installation_type : str
            Type of installation that a README file is generated for
        readme_path : str
            Non-standard readme path. Standard is install_location/INSTALL_README.txt
        module : installSynApps.DataModel.install_module.InstallModule
            Default none. If not None, module that is being packaged as add-on
        """

        # Open the correct readme file path in write mode, set the top location
        if readme_path is None:
            if os.path.exists(os.path.join(self.install_config.install_location, 'INSTALL_README.txt')):
                os.remove(os.path.join(self.install_config.install_location, 'INSTALL_README.txt'))
            readme_fp = open(os.path.join(self.install_config.install_location, 'INSTALL_README.txt'), 'w')
            top_location = self.install_config.install_location
        else:
            readme_fp = open(readme_path, 'w')
            top_location = '__temp__'

        # Write heading based on type of installation
        if installation_type == 'source':
            self.write_readme_heading('Source Package - {}'.format(installation_name), readme_fp)
        elif installation_type == 'bundle':
            self.write_readme_heading('Bundle - {}'.format(installation_name), readme_fp)
        elif installation_type == 'addon':
            self.write_readme_heading('Add-On - {}'.format(installation_name), readme_fp)
        
        # Grab some basic version info
        isa_version, commit_hash = self.find_isa_version()
        readme_fp.write('Package generated using installSynApps version: {}\n'.format(isa_version))
        readme_fp.write('See below for build tool version information.\n')
        readme_fp.write('\nModule versions used in this deployment:\n')
        if module is not None:
            readme_fp.write('\nAdd-On should be located here: {}.\n\n'.format(module.rel_path))
        readme_fp.write('[folder name] - [git tag]\n\n')

        # Get included modules + versions
        self.write_included_modules_to_readme(installation_type, module, readme_fp)

        # If it is an add-on-package, list what modules it was built against
        if module is not None:
            readme_fp.write('\nThe module was built against:\n\n')
            self.write_included_modules_to_readme('source', None, readme_fp)

        readme_fp.write('\n\n')

        # Grab some final build configuration information, and close the file.
        self.grab_configuration_used(top_location, module, readme_fp)
        readme_fp.close()


    def generate_build_config(self, top_location, module, readme_fp):
        """Function that writes the build configuration used to create the source/binary package.

        Parameters
        ----------
        top_location : str
            Output location of the package
        module : installSynApps.DataModel.install_module.InstallModule
            If not None, module being packaged as add on
        readme_fp : file pointer
            Open file pointer for README file.
        """

        if module is None:
            LOG.write('Copying build configuration into bundle.')
            writer = WRITER.ConfigWriter(self.install_config)
            build_config_dir = os.path.join(top_location, 'build-config')
            writer.write_install_config(filepath=build_config_dir, overwrite_existing=True)
            self.write_readme_heading('Build environment version information', readme_fp)
        else:
            self.write_readme_heading('Implementing add on in exisitng bundle', readme_fp)
            readme_fp.write('This add on tarball contains a folder with a compiled version of {}.\n'.format(module.name))
            readme_fp.write('To use it with an existing bundle, please copy the folder into {} in the target bundle.\n'.format(module.rel_path))
            readme_fp.write('It is also recommended to edit the build-config for the bundle to reflect the inclusion of this module.\n\n')


    def autogenerate_all(self, create_simple_readme=True):
        """Top level function that calls all autogeneration functions

        Parameters
        ----------
        create_simple_readme : bool
            If true, generate simplified README file based on install config
        """

        self.initialize_dir()
        self.generate_install()
        self.generate_uninstall()
        if create_simple_readme:
            self.generate_readme_simple()